{
  "version": 3,
  "sources": [
    "node_modules/browser-pack/_prelude.js",
    "showy.js",
    "src/showy.js",
    "src/transitions.js"
  ],
  "names": [],
  "mappings": "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",
  "file": "generated.js",
  "sourceRoot": "",
  "sourcesContent": [
    "(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})",
    "var Showy = require('./src/showy').default;\nShowy.DefaultTransitions = require('./src/transitions').default;\n\nwindow.Showy = Showy;\n\nmodule.exports = Showy;\n",
    "/**\n * TODO\n * - autoplay: wait for slide._loaded\n * - optionally reset video on change\n * - fade objects on load\n * - events (ready, progress etc)\n * - cache video frames (assume frame rate and round currentTime to get frame)\n * - video options (loop?, sound?)\n * - fallback for no-video / autoplay on mobile\n * - effects/filters (sepia / grayscale etc)\n * - fallback for no-webgl (use gsap?)\n */\n\nconst TRANSITION_FORWARDS = 'forwards';\nconst TRANSITION_BACKWARDS = 'backwards';\nconst TRANSITION_RANDOM = 'random';\n\nconst TRANSITION_NONE_SHADER = `\n  #ifdef GL_ES\n  precision highp float;\n  #endif\n  uniform sampler2D from, to;\n  uniform float progress;\n  uniform vec2 resolution;\n\n  void main() {\n    vec2 p = gl_FragCoord.xy / resolution.xy;\n    gl_FragColor = texture2D(to, p);\n  }\n`;\n\n// Polyfill playing status\nObject.defineProperty(HTMLMediaElement.prototype, 'playing', {\n  get: function () {\n    return !!(this.currentTime > 0 && !this.paused && !this.ended && this.readyState > 2);\n  },\n});\n\nclass Showy {\n  constructor(config) {\n    const defaultConfig = {\n      container: 'body',\n      slides: [],\n      autoplay: false,\n      slideDuration: 3000,\n      transitions: Showy.DefaultTransitions,\n      transition: {\n        name: 'random',\n        duration: 2000,\n        ease: 'linear',\n        priority: 0,\n      },\n    };\n\n    this.config = _.merge({}, defaultConfig, config);\n\n    if (typeof this.config.container === 'string') {\n      this.container = document.querySelector(this.config.container);\n    } else {\n      this.container = this.config.container;\n    }\n\n    this.container.style.display = 'block';\n    this.container.style.position = 'absolute';\n    this.container.style.top = '0';\n    this.container.style.left = '0';\n    this.container.style.width = '100%';\n    this.container.style.height = '100%';\n\n    this._slides = this.config.slides;\n    this._currentSlideIndex = this._transitionToIndex = 0;\n    this._currentSlideRendered = false;\n    this._transitionProgress = 0;\n    this._imageMap = {};\n    this._videoMap = {};\n    this._slideContentMap = {};\n    this._ready = false;\n    this._destroyed = false;\n    this._playing = this.config.autoplay;\n\n    this._createCanvases();\n\n    this._resizeHandler = this.resize.bind(this);\n    window.addEventListener('resize', this._resizeHandler);\n\n    this._lastFrameTime = 0;\n    window.requestAnimationFrame(this._animate.bind(this));\n  }\n\n  goToSlide(index, direction) {\n    this._transitionToIndex = index;\n    this._transitionDirection = direction;\n\n    this._currentSlideRendered = false;\n\n    if (this._autoPlayTimeout) {\n      clearTimeout(this._autoPlayTimeout);\n    }\n  }\n\n  nextSlide() {\n    let index;\n\n    if (this._transitionToIndex === this._currentSlideIndex - 1 || (this._transitionToIndex === this._slides.length - 1 && this._currentSlideIndex === 0)) {\n      // Cancel and reverse the transition\n      index = this._currentSlideIndex;\n\n    } else {\n      index = this._currentSlideIndex === this._slides.length - 1 ? 0 : this._currentSlideIndex + 1;\n    }\n\n    this.goToSlide(index, TRANSITION_FORWARDS);\n  }\n\n  prevSlide() {\n    let index;\n\n    if (this._transitionToIndex === this._currentSlideIndex + 1 || (this._transitionToIndex === 0 && this._currentSlideIndex === this._slides.length - 1)) {\n      // Cancel and reverse the transition\n      index = this._currentSlideIndex;\n\n    } else {\n      index = this._currentSlideIndex === 0 ? this._slides.length - 1 : this._currentSlideIndex - 1;\n    }\n\n    this.goToSlide(index, TRANSITION_BACKWARDS);\n  }\n\n  play() {\n    this._playing = true;\n\n    this.nextSlide();\n  }\n\n  pause() {\n    this._playing = false;\n\n    if (this._autoPlayTimeout) {\n      clearTimeout(this._autoPlayTimeout);\n    }\n  }\n\n  destroy() {\n    this._playing = false;\n\n    this._destroyed = true;\n\n    window.removeEventListener('resize', this._resizeHandler);\n\n    _.forEach(this._videoMap, video => {\n      this.container.removeChild(video);\n      video = null;\n    });\n    this._videoMap = null;\n  }\n\n  _transitionEnded() {\n    // console.log('Transition Ended');\n  }\n\n  _videoEnded(video, videoObject) {\n    // console.log('Video Ended');\n\n    const slide = this._slides[this._transitionToIndex];\n\n    if (this._playing) {\n      if (slide.duration && _.isFunction(slide.duration)) {\n        let object = slide.duration();\n\n        if (object.type === 'video') {\n          this.nextSlide();\n        }\n      }\n    }\n  }\n\n  _slideLoaded(slide, slideIndex) {\n    // console.log('Slide Loaded');\n  }\n\n  _slideRendered() {\n    // console.log('Slide Rendered');\n\n    if (!this._ready) {\n      // Showy is ready for the first time\n      this._ready = true;\n      this.container.classList.add('showy--ready');\n    }\n\n    const slide = this._slides[this._transitionToIndex];\n\n    if (this._playing) {\n      let slideDuration = this.config.slideDuration;\n\n      if (slide.duration) {\n        if (_.isFunction(slide.duration)) {\n          let object = slide.duration();\n\n          if (object.type === 'video') {\n            return;\n          }\n        }\n\n        if (_.isNumber(slide.duration)) {\n          slideDuration = slide.duration;\n        }\n      }\n\n      this._autoPlayTimeout = setTimeout(() => {\n        this.nextSlide();\n      }, slideDuration);\n    }\n  }\n\n  _animate(frameTime) {\n    if (this._destroyed) {\n      return;\n    }\n\n    this._fps = 1000 / (frameTime - this._lastFrameTime);\n\n    try {\n      this._drawSlides();\n\n      window.requestAnimationFrame(this._animate.bind(this));\n\n    } catch (error) {\n      console.error(error.stack);\n    }\n\n    this._lastFrameTime = frameTime;\n  }\n\n  _createCanvas() {\n    const canvas = document.createElement('canvas');\n    canvas.style.position = 'absolute';\n    canvas.style.width = '100%';\n    canvas.style.height = '100%';\n    this._resizeCanvas(canvas);\n    return canvas;\n  }\n\n  _createCanvases() {\n    this._currentCanvas = this._createCanvas();\n    this._currentContext = this._currentCanvas.getContext('2d');\n\n    this._nextCanvas = this._createCanvas();\n    this._nextContext = this._nextCanvas.getContext('2d');\n\n    this._prevCanvas = this._createCanvas();\n    this._prevContext = this._prevCanvas.getContext('2d');\n\n    this._renderCanvas = this._createCanvas();\n    this._renderContext = this._renderCanvas.getContext('webgl') || this._renderCanvas.getContext('experimental-webgl');\n    this._renderContext.pixelStorei(this._renderContext.UNPACK_FLIP_Y_WEBGL, true);\n\n    this.container.appendChild(this._renderCanvas);\n  }\n\n  _resizeCanvas(canvas) {\n    this._scale = window.devicePixelRatio;\n    canvas.width = this.container.clientWidth * this._scale;\n    canvas.height = this.container.clientHeight * this._scale;\n  }\n\n  resize() {\n    // Remove all cached imageData as this will be redundant now\n    this._slideContentMap = {};\n\n    this._resizeCanvas(this._currentCanvas);\n    this._resizeCanvas(this._nextCanvas);\n    this._resizeCanvas(this._prevCanvas);\n    this._resizeCanvas(this._renderCanvas);\n\n    this._drawSlides(true);\n  }\n\n  _clearContext(context) {\n    context.clearRect(0, 0, context.canvas.width, context.canvas.height);\n  }\n\n  _transitionInProgress() {\n    return this._transitionProgress > 0 && this._transitionProgress < 1;\n  }\n\n  _getTransition(currentSlideTransition = {}, nextPrevSlideTransition = {}) {\n    const _currentSlideTransition = _.merge({}, this.config.transition, currentSlideTransition || {});\n    const _nextPrevSlideTransition = _.merge({}, this.config.transition, nextPrevSlideTransition || {});\n    if (_currentSlideTransition.name === TRANSITION_RANDOM) {\n      _currentSlideTransition.glsl = _.sample(this.config.transitions);\n    } else {\n      _currentSlideTransition.glsl = this.config.transitions[_currentSlideTransition.name];\n    }\n    if (_nextPrevSlideTransition.name === TRANSITION_RANDOM) {\n      _nextPrevSlideTransition.glsl = _.sample(this.config.transitions);\n    } else {\n      _nextPrevSlideTransition.glsl = this.config.transitions[_nextPrevSlideTransition.name];\n    }\n    const transition = _currentSlideTransition.priority >= _nextPrevSlideTransition.priority ? _currentSlideTransition : _nextPrevSlideTransition;\n    return transition;\n  }\n\n  _drawSlides(reset) {\n    const currentSlide = this._slides[this._currentSlideIndex];\n    const nextSlide = this._slides[this._currentSlideIndex === this._slides.length - 1 ? 0 : this._currentSlideIndex + 1];\n    const prevSlide = this._slides[this._currentSlideIndex === 0 ? this._slides.length - 1 : this._currentSlideIndex - 1];\n\n    let transitionOptions;\n\n    // Rerender the current slide eg. if canvas has been resized\n    if (reset) {\n      currentSlide._rendered = false;\n    }\n\n    // Only render if we need to ie. only during transitions\n    // or if the current slide contains video(s)\n    if (!currentSlide._hasVideo &&\n      currentSlide._rendered &&\n      !this._transitionInProgress() &&\n      this._currentSlideIndex === this._transitionToIndex) {\n      return;\n    }\n\n    this._drawSlide(this._currentContext, currentSlide);\n    this._drawSlide(this._nextContext, nextSlide);\n    this._drawSlide(this._prevContext, prevSlide);\n\n    // Dispose of textures used in previous frame\n    if (this._fromTexture) {\n      this._fromTexture.dispose();\n    }\n    if (this._toTexture) {\n      this._toTexture.dispose();\n    }\n\n    // Transition is already running or has been triggered by a change of _transitionToIndex\n    if (this._transitionToIndex !== this._currentSlideIndex || this._transitionInProgress()) {\n      // We're heading to the next slide (or the transition has been cancelled halfway through)\n      if ((this._transitionToIndex !== this._currentSlideIndex && this._transitionDirection === TRANSITION_FORWARDS) ||\n        (this._transitionToIndex === this._currentSlideIndex && this._transitionDirection === TRANSITION_BACKWARDS)) {\n        this._fromTexture = createTexture(this._renderContext, this._currentCanvas);\n        this._toTexture = createTexture(this._renderContext, this._nextCanvas);\n        transitionOptions = this._getTransition(currentSlide.transitionNext, nextSlide.transitionPrev);\n      }\n      // We're heading to the previous slide (or the transition has been cancelled halfway through)\n      if ((this._transitionToIndex !== this._currentSlideIndex && this._transitionDirection === TRANSITION_BACKWARDS) ||\n        (this._transitionToIndex === this._currentSlideIndex && this._transitionDirection === TRANSITION_FORWARDS)) {\n        this._fromTexture = createTexture(this._renderContext, this._prevCanvas);\n        this._toTexture = createTexture(this._renderContext, this._currentCanvas);\n        transitionOptions = this._getTransition(currentSlide.transitionPrev, prevSlide.transitionNext);\n      }\n\n    } else {\n      // We're not transitioning so just rerender current slide (only if needed)\n      this._fromTexture = createTexture(this._renderContext, this._currentCanvas);\n      this._toTexture = this._fromTexture;\n    }\n\n    if (transitionOptions && !this._transitionInProgress() &&\n      (!this._transitionOptions || this._transitionOptions.name !== transitionOptions.name || this._transitionOptions.name === TRANSITION_RANDOM)) {\n      // Update transition options if required\n      this._transitionOptions = transitionOptions;\n\n      if (this._transition) {\n        // Destroy current transition in preparation to create a new one\n        this._transition.dispose();\n        this._transition = null;\n      }\n    }\n\n    if (this._transitionOptions) {\n      if (!this._transition) {\n        this._transition = createTransition(this._renderContext, this._transitionOptions.glsl.shader);\n      }\n\n      if (this._transitionToIndex !== this._currentSlideIndex || this._transitionInProgress()) {\n        // Increment the transition progress depending on the direction\n        const progressIncrement = 60 / this._transitionOptions.duration;\n\n        if (this._transitionDirection === TRANSITION_FORWARDS) {\n          this._transitionProgress = this._transitionInProgress() ? this._transitionProgress + progressIncrement : progressIncrement;\n        }\n        if (this._transitionDirection === TRANSITION_BACKWARDS) {\n          this._transitionProgress = this._transitionInProgress() ? this._transitionProgress - progressIncrement : 1 - progressIncrement;\n        }\n      }\n\n      // We've reached the end of the transition\n      if (this._transitionProgress > 1) {\n        this._transitionProgress = 1;\n      }\n      if (this._transitionProgress < 0) {\n        this._transitionProgress = 0;\n      }\n\n      const easedTransitionProgress = eases[this._transitionOptions.ease](this._transitionProgress);\n\n      this._transition.render(easedTransitionProgress, this._fromTexture, this._toTexture, this._transitionOptions.glsl.uniforms);\n\n    } else {\n      // No transition specified, just render\n      if (!this._transition) {\n        this._transition = createTransition(this._renderContext, TRANSITION_NONE_SHADER);\n      }\n\n      this._transition.render(1, this._fromTexture, this._toTexture);\n    }\n\n    // We have rendered the current slide for the first time\n    if (currentSlide._ready) {\n      currentSlide._rendered = true;\n\n      if (!this._currentSlideRendered) {\n        this._currentSlideRendered = true;\n\n        this._playSlideContent(this._transitionToIndex);\n\n        this._slideRendered();\n      }\n    }\n\n    // Transition is finished\n    if (this._transitionToIndex !== this._currentSlideIndex && !this._transitionInProgress()) {\n      this._currentSlideIndex = this._transitionToIndex;\n\n      this._clearContext(this._currentContext);\n      this._clearContext(this._nextContext);\n      this._clearContext(this._prevContext);\n\n      this._pauseSlideContent();\n\n      this._transitionEnded();\n    }\n  }\n\n  _drawSlide(context, slide) {\n    slide._hasVideo = slide.content.filter(object => object.type === 'video').length > 0;\n    slide._rendered = false;\n    slide._ready = false;\n    if (!slide._loaded) {\n      slide._loaded = false;\n    }\n\n    if (slide.background) {\n      context.fillStyle = slide.background;\n      context.fillRect(0, 0, context.canvas.width, context.canvas.height);\n    }\n\n    if (slide.content.length) {\n      this._drawSlideContent(context, slide, 0);\n    }\n  }\n\n  _drawSlideContent(context, slide, index) {\n    const object = slide.content[index];\n\n    if (!object) {\n      slide._ready = true;\n\n      if (!slide._loaded) {\n        slide._loaded = true;\n        this._slideLoaded(slide, this._slides.indexOf(slide));\n      }\n      return;\n    }\n\n    const callback = this._drawSlideContent.bind(this, context, slide, index + 1);\n\n    switch (object.type) {\n      case 'image':\n        this._drawImage(context, object, callback);\n        break;\n      case 'video':\n        this._drawVideo(context, object, callback);\n        break;\n      default:\n        throw new Error('Unknown content type');\n    }\n  }\n\n  _position2Pixels(position, scale = 1) {\n    const _pixels = [];\n\n    position.forEach((val, index) => {\n      let pixel;\n\n      let length = [this._currentCanvas.width, this._currentCanvas.height, this._currentCanvas.width, this._currentCanvas.height][index];\n\n      length /= scale;\n\n      if (val >= 0 && val <= 1) {\n        if (index < 2) {\n          pixel = val * length;\n        } else {\n          pixel = (val * length) - _pixels[index - 2];\n        }\n      } else {\n        if (index < 2) {\n          pixel = val;\n        } else {\n          pixel = length - _pixels[index - 2] - Math.abs(val);\n        }\n      }\n\n      _pixels.push(pixel);\n    });\n\n    const pixels = {\n      x: _pixels[0] * scale,\n      y: _pixels[1] * scale,\n      width: _pixels[2] * scale,\n      height: _pixels[3] * scale,\n    };\n\n    return pixels;\n  }\n\n  _updateCoords(src, dst, scaleMode) {\n    const srcRatio = src.width / src.height;\n    const dstRatio = dst.width / dst.height;\n\n    if (scaleMode && scaleMode === 'fill') {\n      if (srcRatio < dstRatio) {\n        const newHeight = dst.height * (src.width / dst.width);\n        src.y = src.y + ((src.height - newHeight) * 0.5);\n        src.height = newHeight;\n      }\n      if (srcRatio > dstRatio) {\n        const newWidth = dst.width * (src.height / dst.height);\n        src.x = src.x + ((src.width - newWidth) * 0.5);\n        src.width = newWidth;\n      }\n    } else {\n      if (srcRatio > dstRatio) {\n        const newHeight = dst.width * (src.height / src.width);\n        dst.y = dst.y + ((dst.height - newHeight) * 0.5);\n        dst.height = newHeight;\n      }\n      if (srcRatio < dstRatio) {\n        const newWidth = dst.height * srcRatio;\n        dst.x = dst.x + ((dst.width - newWidth) * 0.5);\n        dst.width = newWidth;\n      }\n    }\n\n    // Round properties for pica (and general speed up)\n    const roundProps = ['x', 'y', 'width', 'height'];\n\n    roundProps.forEach(prop => {\n      src[prop] = Math.round(src[prop]);\n      dst[prop] = Math.round(dst[prop]);\n    });\n\n    return {\n      src,\n      dst,\n    };\n  }\n\n  _getTile(dst, size) {\n    return {\n      x: dst.x,\n      y: dst.y,\n      width: size[0] <= 1 ? dst.width * size[0] : size[0],\n      height: size[1] <= 1 ? dst.height * size[1] : size[1],\n    };\n  }\n\n  _drawTiles(dst, tile, scaleMode, callback) {\n    let rows;\n    let columns;\n\n    let offsetWidth = 0;\n    let offsetHeight = 0;\n\n    if (scaleMode && scaleMode === 'fill') {\n      rows = Math.ceil(dst.height / tile.height);\n      columns = Math.ceil(dst.width / tile.width);\n\n      offsetWidth = ((tile.width * columns) - dst.width) * 0.5;\n      offsetHeight = ((tile.height * rows) - dst.height) * 0.5;\n\n    } else {\n      rows = Math.floor(dst.height / tile.height);\n      columns = Math.floor(dst.width / tile.width);\n    }\n\n    let row = 0;\n    let column = 0;\n\n    const totalTiles = rows * columns;\n\n    for (let i = 0; i < totalTiles; i++) {\n      callback({\n        x: (tile.x + (column * tile.width)) - offsetWidth,\n        y: (tile.y + (row * tile.height)) - offsetHeight,\n      });\n\n      if (column === columns - 1) {\n        row++;\n      }\n\n      column = column < columns - 1 ? column + 1 : 0;\n    }\n  }\n\n  _getImageData(image, x, y, width, height) {\n    const tempCanvas = document.createElement('canvas');\n    tempCanvas.width = image.naturalWidth;\n    tempCanvas.height = image.naturalHeight;\n    const tempContext = tempCanvas.getContext('2d');\n    tempContext.drawImage(image, 0, 0, image.naturalWidth, image.naturalHeight);\n    return tempContext.getImageData(x, y, width, height).data;\n  }\n\n  _getImage(imageUrl, callback) {\n    if (this._imageMap[imageUrl]) {\n      callback(this._imageMap[imageUrl]);\n      return;\n    }\n\n    const image = new Image();\n    image.crossOrigin = 'Anonymous';\n    image.src = imageUrl;\n    image.onerror = event => {\n      this.destroy();\n\n      throw new Error('Image failed to load', imageUrl);\n    };\n    image.onload = event => {\n      this._imageMap[imageUrl] = image;\n      callback(image);\n    };\n  }\n\n  _resizeImage(image, src, dst, callback) {\n    const resizedImageKey = JSON.stringify({\n      src: image.src,\n      dst,\n    });\n\n    if (this._slideContentMap[resizedImageKey]) {\n      callback(this._slideContentMap[resizedImageKey]);\n      return;\n    }\n\n    pica.resizeBuffer({\n      src: this._getImageData(image, src.x, src.y, src.width, src.height),\n      width: src.width,\n      height: src.height,\n      toWidth: dst.width,\n      toHeight: dst.height,\n      quality: 1,\n      alpha: false,\n      unsharpAmount: 0,\n      unsharpRadius: 0.5,\n      unsharpThreshold: 0,\n    }, (error, buffer) => {\n      if (error) {\n        console.error(error);\n        return;\n      }\n\n      if (buffer.length) {\n        const resizedImageData = new ImageData(new Uint8ClampedArray(buffer), dst.width, dst.height);\n\n        this._slideContentMap[resizedImageKey] = resizedImageData;\n\n        callback(this._slideContentMap[resizedImageKey]);\n\n        return;\n      }\n\n      console.error(new Error('Resize failed'), image.src, src, dst);\n    });\n  }\n\n  _drawImage(context, object, callback) {\n    this._getImage(object.url, image => {\n      let src = {\n        x: 0,\n        y: 0,\n        width: image.naturalWidth,\n        height: image.naturalHeight,\n      };\n\n      let dst = this._position2Pixels(object.position, this._scale);\n\n      if (object.tile) {\n        let tile = this._getTile(dst, object.tile.size);\n\n        const updatedCoords = this._updateCoords(src, tile, object.tile.scaleMode);\n\n        this._resizeImage(image, updatedCoords.src, updatedCoords.dst, resizedImageData => {\n\n          this._drawTiles(dst, updatedCoords.dst, object.scaleMode, tileCoord => {\n            context.putImageData(resizedImageData, tileCoord.x, tileCoord.y);\n          });\n\n          callback();\n        });\n\n        return;\n      }\n\n      const updatedCoords = this._updateCoords(src, dst, object.scaleMode);\n\n      src = updatedCoords.src;\n      dst = updatedCoords.dst;\n\n      this._resizeImage(image, src, dst, resizedImageData => {\n        context.putImageData(resizedImageData, dst.x, dst.y);\n\n        callback();\n      });\n    });\n  }\n\n  _getVideoData(video) {\n    const tempCanvas = document.createElement('canvas');\n    tempCanvas.width = video.videoWidth;\n    tempCanvas.height = video.videoHeight;\n    const tempContext = tempCanvas.getContext('2d');\n    tempContext.drawImage(video, 0, 0, video.videoWidth, video.videoHeight);\n    return tempContext._getImageData(0, 0, video.videoWidth, video.videoHeight).data;\n  }\n\n  _getVideo(object, callback = () => {}) {\n    const videoKey = JSON.stringify(object.sources);\n\n    if (this._videoMap[videoKey]) {\n      callback(this._videoMap[videoKey]);\n\n      return this._videoMap[videoKey];\n    }\n\n    const video = document.createElement('video');\n    video.style.display = 'none';\n    video.crossOrigin = 'anonymous';\n    video.muted = true;\n    this.container.appendChild(video);\n\n    object.sources.forEach(source => {\n      const _source = document.createElement('source');\n      _source.src = source.url;\n      _source.type = source.type;\n      video.appendChild(_source);\n    });\n\n    this._videoMap[videoKey] = video;\n\n    video.addEventListener('loadedmetadata', () => {\n      callback(video);\n    });\n\n    video._playCount = 0;\n\n    video.addEventListener('ended', () => {\n      video.play();\n\n      video._playCount += 1;\n\n      this._videoEnded(video, object);\n    });\n\n    return video;\n  }\n\n  _drawVideo(context, object, callback) {\n    this._getVideo(object, video => {\n      if (video.videoWidth === 0 || video.videoHeight === 0) {\n        return;\n      }\n\n      let src = {\n        x: 0,\n        y: 0,\n        width: video.videoWidth,\n        height: video.videoHeight,\n      };\n\n      let dst = this._position2Pixels(object.position, this._scale);\n\n      if (object.tile) {\n        let tile = this._getTile(dst, object.tile.size);\n\n        const updatedCoords = this._updateCoords(src, tile, object.tile.scaleMode);\n\n        this._drawTiles(dst, updatedCoords.dst, object.scaleMode, tileCoord => {\n          context.drawImage(video, src.x, src.y, src.width, src.height, tileCoord.x, tileCoord.y, tile.width, tile.height);\n        });\n\n        callback();\n\n        return;\n      }\n\n      const updatedCoords = this._updateCoords(src, dst, object.scaleMode);\n\n      src = updatedCoords.src;\n      dst = updatedCoords.dst;\n\n      context.drawImage(video, src.x, src.y, src.width, src.height, dst.x, dst.y, dst.width, dst.height);\n\n      callback();\n    });\n  }\n\n  _playSlideContent(index) {\n    this._slides[index].content.forEach(object => {\n      if (object.type === 'video') {\n        this._getVideo(object, video => {\n          video._playCount = 0;\n          video.currentTime = 0;\n          video.play();\n        });\n      }\n    });\n  }\n\n  _pauseSlideContent() {\n    const currentSlideVideos = [];\n\n    this._slides[this._currentSlideIndex].content.forEach(object => {\n      if (object.type === 'video') {\n        currentSlideVideos.push(this._getVideo(object));\n      }\n    });\n\n    this._slides.forEach((slide, index) => {\n      if (index === this._currentSlideIndex) {\n        return;\n      }\n\n      slide.content.forEach(object => {\n        if (object.type === 'video') {\n          this._getVideo(object, video => {\n            if (currentSlideVideos.indexOf(video) === -1) {\n              video._playCount = 0;\n              video.currentTime = 0;\n              video.pause();\n            }\n          });\n        }\n      });\n    });\n  }\n}\n\nexport default Showy;\n",
    "const transitions = {\n  none: {\n    shader: `\n      #ifdef GL_ES\n      precision highp float;\n      #endif\n      uniform sampler2D from, to;\n      uniform float progress;\n      uniform vec2 resolution;\n\n      void main() {\n        vec2 p = gl_FragCoord.xy / resolution.xy;\n        gl_FragColor = texture2D(to, p);\n      }\n    `,\n    uniforms: {},\n  },\n  crossfade: {\n    shader: `\n      #ifdef GL_ES\n      precision highp float;\n      #endif\n      uniform sampler2D from, to;\n      uniform float progress;\n      uniform vec2 resolution;\n\n      void main() {\n        vec2 p = gl_FragCoord.xy / resolution.xy;\n        gl_FragColor = mix(texture2D(from, p), texture2D(to, p), progress);\n      }\n    `,\n    uniforms: {},\n  },\n  wipeUp: {\n    shader: `\n      #ifdef GL_ES\n      precision highp float;\n      #endif\n      uniform sampler2D from, to;\n      uniform float progress;\n      uniform vec2 resolution;\n\n      void main() {\n        vec2 p = gl_FragCoord.xy / resolution.xy;\n        vec4 a = texture2D(from, p);\n        vec4 b = texture2D(to, p);\n        gl_FragColor = mix(a, b, step(0.0 + p.y, progress));\n      }\n    `,\n    uniforms: {},\n  },\n  wipeDown: {\n    shader: `\n      #ifdef GL_ES\n      precision highp float;\n      #endif\n      uniform sampler2D from, to;\n      uniform float progress;\n      uniform vec2 resolution;\n\n      void main() {\n        vec2 p = gl_FragCoord.xy / resolution.xy;\n        vec4 a = texture2D(from, p);\n        vec4 b = texture2D(to, p);\n        gl_FragColor = mix(a, b, step(1.0 - p.y, progress));\n      }\n    `,\n    uniforms: {},\n  },\n  wipeRight: {\n    shader: `\n      #ifdef GL_ES\n      precision highp float;\n      #endif\n      uniform sampler2D from, to;\n      uniform float progress;\n      uniform vec2 resolution;\n\n      void main() {\n        vec2 p = gl_FragCoord.xy / resolution.xy;\n        vec4 a = texture2D(from, p);\n        vec4 b = texture2D(to, p);\n        gl_FragColor = mix(a, b, step(0.0 + p.x, progress));\n      }\n    `,\n    uniforms: {},\n  },\n  wipeLeft: {\n    shader: `\n      #ifdef GL_ES\n      precision highp float;\n      #endif\n      uniform sampler2D from, to;\n      uniform float progress;\n      uniform vec2 resolution;\n\n      void main() {\n        vec2 p = gl_FragCoord.xy / resolution.xy;\n        vec4 a = texture2D(from, p);\n        vec4 b = texture2D(to, p);\n        gl_FragColor = mix(a, b, step(1.0 - p.x, progress));\n      }\n    `,\n    uniforms: {},\n  },\n  circle: {\n    shader: `\n      #ifdef GL_ES\n      precision highp float;\n      #endif\n\n      uniform sampler2D from, to;\n      uniform float progress;\n      uniform vec2 resolution;\n\n      uniform float centerX;\n      uniform float centerY;\n      uniform float smoothness;\n      uniform bool grow;\n\n      vec2 center = vec2(centerX, 1.0 - centerY);\n      float scale = sqrt(min(resolution[0] / resolution[1], resolution[1] / resolution[0]) / max(centerX, 1.0 - centerY));\n\n      void main() {\n        vec2 p = gl_FragCoord.xy / resolution.xy;\n        float size = grow ? progress : 1.0 - progress;\n        float dist = distance(center, p);\n        float circle = smoothstep(-smoothness, 0.0, scale * dist - size * (1.0 + smoothness));\n        gl_FragColor = mix(texture2D(from, p), texture2D(to, p), grow ? 1.0 - circle : circle);\n      }\n    `,\n    uniforms: {\n      centerX: 0.5,\n      centerY: 0.5,\n      smoothness: 0,\n      grow: true,\n    },\n  },\n  circleInOut: {\n    shader: `\n      #ifdef GL_ES\n      precision highp float;\n      #endif\n      uniform sampler2D from, to;\n      uniform float progress;\n      uniform vec2 resolution;\n\n      float maxRadius = resolution.x + resolution.y;\n\n      void main() {\n        vec2 p = gl_FragCoord.xy / resolution.xy;\n\n        float distX = gl_FragCoord.x - resolution.x / 2.0;\n        float distY = gl_FragCoord.y - resolution.y / 2.0;\n        float dist = sqrt(distX * distX + distY * distY);\n\n        float step = 2.0 * abs(progress - 0.5);\n        step = step * step * step;\n\n        if (dist < step * maxRadius)\n        {\n          if (progress < 0.5)\n            gl_FragColor = texture2D(from, p);\n          else\n            gl_FragColor = texture2D(to, p);\n        }\n        else\n          gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\n      }\n    `,\n    uniforms: {},\n  },\n  splitVertical: {\n    shader: `\n      #ifdef GL_ES\n      precision highp float;\n      #endif\n\n      // General parameters\n      uniform sampler2D from;\n      uniform sampler2D to;\n      uniform float progress;\n      uniform vec2 resolution;\n\n      uniform float reflection;\n      uniform float perspective;\n      uniform float depth;\n\n      const vec4 black = vec4(0.0, 0.0, 0.0, 1.0);\n      const vec2 boundMin = vec2(0.0, 0.0);\n      const vec2 boundMax = vec2(1.0, 1.0);\n\n      bool inBounds (vec2 p) {\n        return all(lessThan(boundMin, p)) && all(lessThan(p, boundMax));\n      }\n\n      vec2 project (vec2 p) {\n        return p * vec2(1.0, -1.2) + vec2(0.0, -0.02);\n      }\n\n      vec4 bgColor (vec2 p, vec2 pto) {\n        vec4 c = black;\n        pto = project(pto);\n        if (inBounds(pto)) {\n          c += mix(black, texture2D(to, pto), reflection * mix(1.0, 0.0, pto.y));\n        }\n        return c;\n      }\n\n      void main() {\n        vec2 p = gl_FragCoord.xy / resolution.xy;\n\n        vec2 pfr = vec2(-1.), pto = vec2(-1.);\n\n        float middleSlit = 2.0 * abs(p.x-0.5) - progress;\n        if (middleSlit > 0.0) {\n          pfr = p + (p.x > 0.5 ? -1.0 : 1.0) * vec2(0.5*progress, 0.0);\n          float d = 1.0/(1.0+perspective*progress*(1.0-middleSlit));\n          pfr.y -= d/2.;\n          pfr.y *= d;\n          pfr.y += d/2.;\n        }\n\n        float size = mix(1.0, depth, 1.-progress);\n        pto = (p + vec2(-0.5, -0.5)) * vec2(size, size) + vec2(0.5, 0.5);\n\n        if (inBounds(pfr)) {\n          gl_FragColor = texture2D(from, pfr);\n        }\n        else if (inBounds(pto)) {\n          gl_FragColor = texture2D(to, pto);\n        }\n        else {\n          gl_FragColor = bgColor(p, pto);\n        }\n      }\n    `,\n    uniforms: {\n      reflection: 0,\n      perspective: 0,\n      depth: 1,\n    },\n  },\n  slideUp: {\n    shader: `\n      #ifdef GL_ES\n      precision highp float;\n      #endif\n      uniform sampler2D from, to;\n      uniform float progress;\n      uniform vec2 resolution;\n\n      uniform float translateX;\n      uniform float translateY;\n\n      void main() {\n          vec2 texCoord = gl_FragCoord.xy / resolution.xy;\n          float x = progress * translateX;\n          float y = progress * translateY;\n\n          if (x >= 0.0 && y >= 0.0) {\n              if (texCoord.x >= x && texCoord.y >= y) {\n                  gl_FragColor = texture2D(from, texCoord - vec2(x, y));\n              }\n              else {\n                  vec2 uv;\n                  if (x > 0.0)\n                      uv = vec2(x - 1.0, y);\n                  else if (y > 0.0)\n                      uv = vec2(x, y - 1.0);\n                  gl_FragColor = texture2D(to, texCoord - uv);\n              }\n          }\n          else if (x <= 0.0 && y <= 0.0) {\n              if (texCoord.x <= (1.0 + x) && texCoord.y <= (1.0 + y))\n                  gl_FragColor = texture2D(from, texCoord - vec2(x, y));\n              else {\n                  vec2 uv;\n                  if (x < 0.0)\n                      uv = vec2(x + 1.0, y);\n                  else if (y < 0.0)\n                      uv = vec2(x, y + 1.0);\n                  gl_FragColor = texture2D(to, texCoord - uv);\n              }\n          }\n          else\n              gl_FragColor = vec4(0.0);\n      }\n    `,\n    uniforms: {\n      translateX: 0,\n      translateY: 1,\n    },\n  },\n  slideDown: {\n    shader: `\n      #ifdef GL_ES\n      precision highp float;\n      #endif\n      uniform sampler2D from, to;\n      uniform float progress;\n      uniform vec2 resolution;\n\n      uniform float translateX;\n      uniform float translateY;\n\n      void main() {\n          vec2 texCoord = gl_FragCoord.xy / resolution.xy;\n          float x = progress * translateX;\n          float y = progress * translateY;\n\n          if (x >= 0.0 && y >= 0.0) {\n              if (texCoord.x >= x && texCoord.y >= y) {\n                  gl_FragColor = texture2D(from, texCoord - vec2(x, y));\n              }\n              else {\n                  vec2 uv;\n                  if (x > 0.0)\n                      uv = vec2(x - 1.0, y);\n                  else if (y > 0.0)\n                      uv = vec2(x, y - 1.0);\n                  gl_FragColor = texture2D(to, texCoord - uv);\n              }\n          }\n          else if (x <= 0.0 && y <= 0.0) {\n              if (texCoord.x <= (1.0 + x) && texCoord.y <= (1.0 + y))\n                  gl_FragColor = texture2D(from, texCoord - vec2(x, y));\n              else {\n                  vec2 uv;\n                  if (x < 0.0)\n                      uv = vec2(x + 1.0, y);\n                  else if (y < 0.0)\n                      uv = vec2(x, y + 1.0);\n                  gl_FragColor = texture2D(to, texCoord - uv);\n              }\n          }\n          else\n              gl_FragColor = vec4(0.0);\n      }\n    `,\n    uniforms: {\n      translateX: 0,\n      translateY: -1,\n    },\n  },\n  slideLeft: {\n    shader: `\n      #ifdef GL_ES\n      precision highp float;\n      #endif\n      uniform sampler2D from, to;\n      uniform float progress;\n      uniform vec2 resolution;\n\n      uniform float translateX;\n      uniform float translateY;\n\n      void main() {\n          vec2 texCoord = gl_FragCoord.xy / resolution.xy;\n          float x = progress * translateX;\n          float y = progress * translateY;\n\n          if (x >= 0.0 && y >= 0.0) {\n              if (texCoord.x >= x && texCoord.y >= y) {\n                  gl_FragColor = texture2D(from, texCoord - vec2(x, y));\n              }\n              else {\n                  vec2 uv;\n                  if (x > 0.0)\n                      uv = vec2(x - 1.0, y);\n                  else if (y > 0.0)\n                      uv = vec2(x, y - 1.0);\n                  gl_FragColor = texture2D(to, texCoord - uv);\n              }\n          }\n          else if (x <= 0.0 && y <= 0.0) {\n              if (texCoord.x <= (1.0 + x) && texCoord.y <= (1.0 + y))\n                  gl_FragColor = texture2D(from, texCoord - vec2(x, y));\n              else {\n                  vec2 uv;\n                  if (x < 0.0)\n                      uv = vec2(x + 1.0, y);\n                  else if (y < 0.0)\n                      uv = vec2(x, y + 1.0);\n                  gl_FragColor = texture2D(to, texCoord - uv);\n              }\n          }\n          else\n              gl_FragColor = vec4(0.0);\n      }\n    `,\n    uniforms: {\n      translateX: 1,\n      translateY: 0,\n    },\n  },\n  slideRight: {\n    shader: `\n      #ifdef GL_ES\n      precision highp float;\n      #endif\n      uniform sampler2D from, to;\n      uniform float progress;\n      uniform vec2 resolution;\n\n      uniform float translateX;\n      uniform float translateY;\n\n      void main() {\n          vec2 texCoord = gl_FragCoord.xy / resolution.xy;\n          float x = progress * translateX;\n          float y = progress * translateY;\n\n          if (x >= 0.0 && y >= 0.0) {\n              if (texCoord.x >= x && texCoord.y >= y) {\n                  gl_FragColor = texture2D(from, texCoord - vec2(x, y));\n              }\n              else {\n                  vec2 uv;\n                  if (x > 0.0)\n                      uv = vec2(x - 1.0, y);\n                  else if (y > 0.0)\n                      uv = vec2(x, y - 1.0);\n                  gl_FragColor = texture2D(to, texCoord - uv);\n              }\n          }\n          else if (x <= 0.0 && y <= 0.0) {\n              if (texCoord.x <= (1.0 + x) && texCoord.y <= (1.0 + y))\n                  gl_FragColor = texture2D(from, texCoord - vec2(x, y));\n              else {\n                  vec2 uv;\n                  if (x < 0.0)\n                      uv = vec2(x + 1.0, y);\n                  else if (y < 0.0)\n                      uv = vec2(x, y + 1.0);\n                  gl_FragColor = texture2D(to, texCoord - uv);\n              }\n          }\n          else\n              gl_FragColor = vec4(0.0);\n      }\n    `,\n    uniforms: {\n      translateX: -1,\n      translateY: 0,\n    },\n  },\n};\n\nexport default transitions;\n"
  ]
}